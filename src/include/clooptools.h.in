/*
	clooptools.h
		the C/C++ header file with all definitions for LoopTools
		this file is part of LoopTools
		last modified 18 Mar 13 th
*/


#ifndef CLOOPTOOLS_H
#define CLOOPTOOLS_H

#define AARGS(t) t(m)

#define BARGS(t) t(p), t(m1), t(m2)

#define CARGS(t) t(p1), t(p2), t(p1p2), t(m1), t(m2), t(m3)

#define DARGS(t) t(p1), t(p2), t(p3), t(p4), t(p1p2), t(p2p3), \
  t(m1), t(m2), t(m3), t(m4)

#define EARGS(t) t(p1), t(p2), t(p3), t(p4), t(p5), \
  t(p1p2), t(p2p3), t(p3p4), t(p4p5), t(p5p1), \
  t(m1), t(m2), t(m3), t(m4), t(m5)

#define XARGS(t) t(x)

#define _lt_Cr_(v) cRealType v
#define _lt_Cc_(v) cComplexType v
#define _lt_Fr_(v) CREAL *v
#define _lt_Fc_(v) CCOMPLEX *v
#define _lt_Id_(v) v

#if QUAD
#define _lt_CFr_(v) v##_ = ToREAL(v)
#define _lt_CFc_(v) v##_ = {ToREAL(Re(v)), ToREAL(Im(v))}
#define _lt_Frp_(v) &v##_
#define _lt_Fcp_(v) &v##_
#define _lt_Fap_(v) v##_
#define _lt_Frd_(f) CREAL f(_lt_CFr_)
#define _lt_Fcd_(f) CCOMPLEX f(_lt_CFc_)
#define _lt_Fad_(v,n) COMPLEX v##_[n];
#define _lt_Fax_(v,n) ToRealArray((RealType *)v, (REAL *)v##_, 2*n);
#else
#define _lt_Frp_(v) &v
#define _lt_Fcp_(v) (CCOMPLEX *)&v
#define _lt_Fap_(v) (COMPLEX *)v
#define _lt_Frd_(f)
#define _lt_Fcd_(f)
#define _lt_Fad_(v,n)
#define _lt_Fax_(v,n)
#endif

enum {
  bb0, bb1, bb00, bb11, bb001, bb111, dbb0, dbb1, dbb00, dbb11,
  Nbb
};

enum {
  cc0, cc1, cc2, cc00, cc11, cc12, cc22, cc001, cc002, cc111, cc112,
  cc122, cc222, cc0000, cc0011, cc0012, cc0022, cc1111, cc1112, cc1122,
  cc1222, cc2222,
  Ncc
};

enum {
  dd0, dd1, dd2, dd3, dd00, dd11, dd12, dd13, dd22, dd23, dd33,
  dd001, dd002, dd003, dd111, dd112, dd113, dd122, dd123, dd133, dd222,
  dd223, dd233, dd333, dd0000, dd0011, dd0012, dd0013, dd0022, dd0023,
  dd0033, dd1111, dd1112, dd1113, dd1122, dd1123, dd1133, dd1222, 
  dd1223, dd1233, dd1333, dd2222, dd2223, dd2233, dd2333, dd3333, 
  dd00001, dd00002, dd00003, dd00111, dd00112, dd00113, dd00122, 
  dd00123, dd00133, dd00222, dd00223, dd00233, dd00333, dd11111, 
  dd11112, dd11113, dd11122, dd11123, dd11133, dd11222, dd11223, 
  dd11233, dd11333, dd12222, dd12223, dd12233, dd12333, dd13333, 
  dd22222, dd22223, dd22233, dd22333, dd23333, dd33333,
  Ndd
};

enum {
  ee0, ee1, ee2, ee3, ee4, ee00, ee11, ee12, ee13, ee14, ee22, ee23, 
  ee24, ee33, ee34, ee44, ee001, ee002, ee003, ee004, ee111, ee112, 
  ee113, ee114, ee122, ee123, ee124, ee133, ee134, ee144, ee222,
  ee223, ee224, ee233, ee234, ee244, ee333, ee334, ee344, ee444,
  ee0000, ee0011, ee0012, ee0013, ee0014, ee0022, ee0023, ee0024,
  ee0033, ee0034, ee0044, ee1111, ee1112, ee1113, ee1114, ee1122, 
  ee1123, ee1124, ee1133, ee1134, ee1144, ee1222, ee1223, ee1224,
  ee1233, ee1234, ee1244, ee1333, ee1334, ee1344, ee1444, ee2222,
  ee2223, ee2224, ee2233, ee2234, ee2244, ee2333, ee2334, ee2344,
  ee2444, ee3333, ee3334, ee3344, ee3444, ee4444,
  Nee
};

enum {
  KeyA0 = 1,
  KeyBget = 1<<2,
  KeyC0 = 1<<4,
  KeyD0 = 1<<6,
  KeyE0 = 1<<8,
  KeyEget = 1<<10,
  KeyEgetC = 1<<12,
  KeyAll = KeyA0 + KeyBget + KeyC0 + KeyD0 + KeyE0 + KeyEget + KeyEgetC
};

enum {
  DebugB = 1,
  DebugC = 1<<1,
  DebugD = 1<<2,
  DebugE = 1<<3,
  DebugAll = DebugB + DebugC + DebugD + DebugE
};

typedef long long int memindex;

/****************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern void FORTRAN(a0sub)(COMPLEX *res, AARGS(_lt_Fr_));
extern void FORTRAN(a0subc)(COMPLEX *res, AARGS(_lt_Fc_));
extern void FORTRAN(a00sub)(COMPLEX *res, AARGS(_lt_Fr_));
extern void FORTRAN(a00subc)(COMPLEX *res, AARGS(_lt_Fc_));

extern memindex FORTRAN(bget)(BARGS(_lt_Fr_));
extern memindex FORTRAN(bgetc)(BARGS(_lt_Fc_));
extern void FORTRAN(bput)(COMPLEX *res, BARGS(_lt_Fr_));
extern void FORTRAN(bputc)(COMPLEX *res, BARGS(_lt_Fc_));

extern void FORTRAN(c0sub)(COMPLEX *res, CARGS(_lt_Fr_));
extern void FORTRAN(c0subc)(COMPLEX *res, CARGS(_lt_Fc_));
extern memindex FORTRAN(cget)(CARGS(_lt_Fr_));
extern memindex FORTRAN(cgetc)(CARGS(_lt_Fc_));
extern void FORTRAN(cput)(COMPLEX *res, CARGS(_lt_Fr_));
extern void FORTRAN(cputc)(COMPLEX *res, CARGS(_lt_Fc_));

extern void FORTRAN(d0sub)(COMPLEX *res, DARGS(_lt_Fr_));
extern void FORTRAN(d0subc)(COMPLEX *res, DARGS(_lt_Fc_));
extern memindex FORTRAN(dget)(DARGS(_lt_Fr_));
extern memindex FORTRAN(dgetc)(DARGS(_lt_Fc_));
extern void FORTRAN(dput)(COMPLEX *res, DARGS(_lt_Fr_));
extern void FORTRAN(dputc)(COMPLEX *res, DARGS(_lt_Fc_));

extern void FORTRAN(e0sub)(COMPLEX *res, EARGS(_lt_Fr_));
extern void FORTRAN(e0subc)(COMPLEX *res, EARGS(_lt_Fc_));
extern memindex FORTRAN(eget)(EARGS(_lt_Fr_));
extern memindex FORTRAN(egetc)(EARGS(_lt_Fc_));
extern void FORTRAN(eput)(COMPLEX *res, EARGS(_lt_Fr_));
extern void FORTRAN(eputc)(COMPLEX *res, EARGS(_lt_Fc_));

extern void FORTRAN(li2sub)(COMPLEX *res, XARGS(_lt_Fr_));
extern void FORTRAN(li2csub)(COMPLEX *res, XARGS(_lt_Fc_));

extern void FORTRAN(li2omxsub)(COMPLEX *res, XARGS(_lt_Fr_));
extern void FORTRAN(li2omxcsub)(COMPLEX *res, XARGS(_lt_Fc_));

extern void FORTRAN(ltini)(void);
extern void FORTRAN(ltexi)(void);

extern void FORTRAN(clearcache)(void);
extern void FORTRAN(markcache)(void);
extern void FORTRAN(restorecache)(void);

#define CACHEPTR(n,i) &FORTRAN(ltvars).cache[n][i]

extern struct {		/* MUST match common block ltvars in lt.h! */
  COMPLEX cache[8][2];
  COMPLEX savedptr[8];
  REAL maxdev;
  INTEGER warndigits, errdigits;
  INTEGER serial, versionkey;
  INTEGER debugkey, debugfrom, debugto;
} FORTRAN(ltvars);

extern struct {		/* MUST match common block ltcache in lt.h! */
  INTEGER cmpbits;
} FORTRAN(ltcache);

extern struct {		/* MUST match common block ltregul in ff.h! */
  REAL mudim, im_mudim, delta, lambda, minmass;
} FORTRAN(ltregul);

#ifdef __cplusplus
}
#endif

/****************************************************************/

static inline ComplexType A0(AARGS(_lt_Cr_))
{
  _lt_Frd_(AARGS);
  COMPLEX res;
  FORTRAN(a0sub)(&res, AARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType A0C(AARGS(_lt_Cc_))
{
  _lt_Fcd_(AARGS);
  COMPLEX res;
  FORTRAN(a0subc)(&res, AARGS(_lt_Fcp_));
  return ToComplex(res);
}

static inline ComplexType A00(AARGS(_lt_Cr_))
{
  _lt_Frd_(AARGS);
  COMPLEX res;
  FORTRAN(a00sub)(&res, AARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType A00C(AARGS(_lt_Cc_))
{
  _lt_Fcd_(AARGS);
  COMPLEX res;
  FORTRAN(a00subc)(&res, AARGS(_lt_Fcp_));
  return ToComplex(res);
}

/****************************************************************/

static inline memindex Bget(BARGS(_lt_Cr_))
{
  _lt_Frd_(BARGS);
  return FORTRAN(bget)(BARGS(_lt_Frp_));
}

static inline memindex BgetC(BARGS(_lt_Cc_))
{
  _lt_Fcd_(BARGS);
  return FORTRAN(bgetc)(BARGS(_lt_Fcp_));
}

static inline void Bput(ComplexType *res, BARGS(_lt_Cr_))
{
  _lt_Frd_(BARGS);
  _lt_Fad_(res, Nbb);
  FORTRAN(bput)(_lt_Fap_(res), BARGS(_lt_Frp_));
  _lt_Fax_(res, Nbb);
}

static inline void BputC(ComplexType *res, BARGS(_lt_Cc_))
{
  _lt_Fcd_(BARGS);
  _lt_Fad_(res, Nbb);
  FORTRAN(bputc)(_lt_Fap_(res), BARGS(_lt_Fcp_));
  _lt_Fax_(res, Nbb);
}

static inline COMPLEX *Bcache(const memindex integral)
  { return CACHEPTR(0,integral); }

static inline COMPLEX *BcacheC(const memindex integral)
  { return CACHEPTR(1,integral); }

static inline ComplexType Bval(const int i, const memindex integral)
  { return ToComplex(Bcache(integral)[i]); }

static inline ComplexType BvalC(const int i, const memindex integral)
  { return ToComplex(BcacheC(integral)[i]); }

static inline ComplexType B0i(const int i, BARGS(_lt_Cr_))
  { return Bval(i, Bget(BARGS(_lt_Id_))); }

static inline ComplexType B0iC(const int i, BARGS(_lt_Cc_))
  { return BvalC(i, BgetC(BARGS(_lt_Id_))); }

static inline ComplexType B0(BARGS(_lt_Cr_))
  { return B0i(bb0, BARGS(_lt_Id_)); }
static inline ComplexType B1(BARGS(_lt_Cr_))
  { return B0i(bb1, BARGS(_lt_Id_)); }
static inline ComplexType B00(BARGS(_lt_Cr_))
  { return B0i(bb00, BARGS(_lt_Id_)); }
static inline ComplexType B11(BARGS(_lt_Cr_))
  { return B0i(bb11, BARGS(_lt_Id_)); }
static inline ComplexType B001(BARGS(_lt_Cr_))
  { return B0i(bb001, BARGS(_lt_Id_)); }
static inline ComplexType B111(BARGS(_lt_Cr_))
  { return B0i(bb111, BARGS(_lt_Id_)); }
static inline ComplexType DB0(BARGS(_lt_Cr_))
  { return B0i(dbb0, BARGS(_lt_Id_)); }
static inline ComplexType DB1(BARGS(_lt_Cr_))
  { return B0i(dbb1, BARGS(_lt_Id_)); }
static inline ComplexType DB00(BARGS(_lt_Cr_))
  { return B0i(dbb00, BARGS(_lt_Id_)); }
static inline ComplexType DB11(BARGS(_lt_Cr_))
  { return B0i(dbb11, BARGS(_lt_Id_)); }

static inline ComplexType B0C(BARGS(_lt_Cc_))
  { return B0iC(bb0, BARGS(_lt_Id_)); }
static inline ComplexType B1C(BARGS(_lt_Cc_))
  { return B0iC(bb1, BARGS(_lt_Id_)); }
static inline ComplexType B00C(BARGS(_lt_Cc_))
  { return B0iC(bb00, BARGS(_lt_Id_)); }
static inline ComplexType B11C(BARGS(_lt_Cc_))
  { return B0iC(bb11, BARGS(_lt_Id_)); }
static inline ComplexType B001C(BARGS(_lt_Cc_))
  { return B0iC(bb001, BARGS(_lt_Id_)); }
static inline ComplexType B111C(BARGS(_lt_Cc_))
  { return B0iC(bb111, BARGS(_lt_Id_)); }
static inline ComplexType DB0C(BARGS(_lt_Cc_))
  { return B0iC(dbb0, BARGS(_lt_Id_)); }
static inline ComplexType DB1C(BARGS(_lt_Cc_))
  { return B0iC(dbb1, BARGS(_lt_Id_)); }
static inline ComplexType DB00C(BARGS(_lt_Cc_))
  { return B0iC(dbb00, BARGS(_lt_Id_)); }
static inline ComplexType DB11C(BARGS(_lt_Cc_))
  { return B0iC(dbb11, BARGS(_lt_Id_)); }

/****************************************************************/

static inline ComplexType C0(CARGS(_lt_Cr_))
{
  _lt_Frd_(CARGS);
  COMPLEX res;
  FORTRAN(c0sub)(&res, CARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType C0C(CARGS(_lt_Cc_))
{
  _lt_Fcd_(CARGS);
  COMPLEX res;
  FORTRAN(c0subc)(&res, CARGS(_lt_Fcp_));
  return ToComplex(res);
}

static inline memindex Cget(CARGS(_lt_Cr_))
{
  _lt_Frd_(CARGS);
  return FORTRAN(cget)(CARGS(_lt_Frp_));
}

static inline memindex CgetC(CARGS(_lt_Cc_))
{
  _lt_Fcd_(CARGS);
  return FORTRAN(cgetc)(CARGS(_lt_Fcp_));
}

static inline void Cput(ComplexType *res, CARGS(_lt_Cr_))
{
  _lt_Frd_(CARGS);
  _lt_Fad_(res, Ncc);
  FORTRAN(cput)(_lt_Fap_(res), CARGS(_lt_Frp_));
  _lt_Fax_(res, Ncc);
}

static inline void CputC(ComplexType *res, CARGS(_lt_Cc_))
{
  _lt_Fcd_(CARGS);
  _lt_Fad_(res, Ncc);
  FORTRAN(cputc)(_lt_Fap_(res), CARGS(_lt_Fcp_));
  _lt_Fax_(res, Ncc);
}

static inline COMPLEX *Ccache(const memindex integral)
  { return CACHEPTR(2,integral); }

static inline COMPLEX *CcacheC(const memindex integral)
  { return CACHEPTR(3,integral); }

static inline ComplexType Cval(const int i, const memindex integral)
  { return ToComplex(Ccache(integral)[i]); }

static inline ComplexType CvalC(const int i, const memindex integral)
  { return ToComplex(CcacheC(integral)[i]); }

static inline ComplexType C0i(const int i, CARGS(_lt_Cr_))
  { return Cval(i, Cget(CARGS(_lt_Id_))); }

static inline ComplexType C0iC(const int i, CARGS(_lt_Cc_))
  { return CvalC(i, CgetC(CARGS(_lt_Id_))); }

/****************************************************************/

static inline ComplexType D0(DARGS(_lt_Cr_))
{
  _lt_Frd_(DARGS);
  COMPLEX res;
  FORTRAN(d0sub)(&res, DARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType D0C(DARGS(_lt_Cc_))
{
  _lt_Fcd_(DARGS);
  COMPLEX res;
  FORTRAN(d0subc)(&res, DARGS(_lt_Fcp_));
  return ToComplex(res);
}

static inline memindex Dget(DARGS(_lt_Cr_))
{
  _lt_Frd_(DARGS);
  return FORTRAN(dget)(DARGS(_lt_Frp_));
}

static inline memindex DgetC(DARGS(_lt_Cc_))
{
  _lt_Fcd_(DARGS);
  return FORTRAN(dgetc)(DARGS(_lt_Fcp_));
}

static inline void Dput(ComplexType *res, DARGS(_lt_Cr_))
{
  _lt_Frd_(DARGS);
  _lt_Fad_(res, Ndd);
  FORTRAN(dput)(_lt_Fap_(res), DARGS(_lt_Frp_));
  _lt_Fax_(res, Ndd);
}

static inline void DputC(ComplexType *res, DARGS(_lt_Cc_))
{
  _lt_Fcd_(DARGS);
  _lt_Fad_(res, Ndd);
  FORTRAN(dputc)(_lt_Fap_(res), DARGS(_lt_Fcp_));
  _lt_Fax_(res, Ndd);
}

static inline COMPLEX *Dcache(const memindex integral)
  { return CACHEPTR(4,integral); }

static inline COMPLEX *DcacheC(const memindex integral)
  { return CACHEPTR(5,integral); }

static inline ComplexType Dval(const int i, const memindex integral)
  { return ToComplex(Dcache(integral)[i]); }

static inline ComplexType DvalC(const int i, const memindex integral)
  { return ToComplex(DcacheC(integral)[i]); }

static inline ComplexType D0i(const int i, DARGS(_lt_Cr_))
  { return Dval(i, Dget(DARGS(_lt_Id_))); }

static inline ComplexType D0iC(const int i, DARGS(_lt_Cc_))
  { return DvalC(i, DgetC(DARGS(_lt_Id_))); }

/****************************************************************/

static inline ComplexType E0(EARGS(_lt_Cr_))
{
  _lt_Frd_(EARGS);
  COMPLEX res;
  FORTRAN(e0sub)(&res, EARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType E0C(EARGS(_lt_Cc_))
{
  _lt_Fcd_(EARGS);
  COMPLEX res;
  FORTRAN(e0subc)(&res, EARGS(_lt_Fcp_));
  return ToComplex(res);
}

static inline memindex Eget(EARGS(_lt_Cr_))
{
  _lt_Frd_(EARGS);
  return FORTRAN(eget)(EARGS(_lt_Frp_));
}

static inline memindex EgetC(EARGS(_lt_Cc_))
{
  _lt_Fcd_(EARGS);
  return FORTRAN(egetc)(EARGS(_lt_Fcp_));
}

static inline void Eput(ComplexType *res, EARGS(_lt_Cr_))
{
  _lt_Frd_(EARGS);
  _lt_Fad_(res, Nee);
  FORTRAN(eput)(_lt_Fap_(res), EARGS(_lt_Frp_));
  _lt_Fax_(res, Nee);
}

static inline void EputC(ComplexType *res, EARGS(_lt_Cc_))
{
  _lt_Fcd_(EARGS);
  _lt_Fad_(res, Nee);
  FORTRAN(eputc)(_lt_Fap_(res), EARGS(_lt_Fcp_));
  _lt_Fax_(res, Nee);
}

static inline COMPLEX *Ecache(const memindex integral)
  { return CACHEPTR(6,integral); }

static inline COMPLEX *EcacheC(const memindex integral)
  { return CACHEPTR(7,integral); }

static inline ComplexType Eval(const int i, const memindex integral)
  { return ToComplex(Ecache(integral)[i]); }

static inline ComplexType EvalC(const int i, const memindex integral)
  { return ToComplex(EcacheC(integral)[i]); }

static inline ComplexType E0i(const int i, EARGS(_lt_Cr_))
  { return Eval(i, Eget(EARGS(_lt_Id_))); }

static inline ComplexType E0iC(const int i, EARGS(_lt_Cc_))
  { return EvalC(i, EgetC(EARGS(_lt_Id_))); }

/****************************************************************/

static inline ComplexType Li2(XARGS(_lt_Cr_))
{
  _lt_Frd_(XARGS);
  COMPLEX res;
  FORTRAN(li2sub)(&res, XARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType Li2C(XARGS(_lt_Cc_))
{
  _lt_Fcd_(XARGS);
  COMPLEX res;
  FORTRAN(li2csub)(&res, XARGS(_lt_Fcp_));
  return ToComplex(res);
}

static inline ComplexType Li2omx(XARGS(_lt_Cr_))
{
  _lt_Frd_(XARGS);
  COMPLEX res;
  FORTRAN(li2sub)(&res, XARGS(_lt_Frp_));
  return ToComplex(res);
}

static inline ComplexType Li2omxC(XARGS(_lt_Cc_))
{
  _lt_Fcd_(XARGS);
  COMPLEX res;
  FORTRAN(li2csub)(&res, XARGS(_lt_Fcp_));
  return ToComplex(res);
}

/****************************************************************/

#define clearcache FORTRAN(clearcache)
#define markcache FORTRAN(markcache)
#define restorecache FORTRAN(restorecache)
#define ltini FORTRAN(ltini)
#define ltexi FORTRAN(ltexi)


static inline void setmudim(cRealType mudim)
{
  FORTRAN(ltregul).mudim = ToREAL(mudim);
  clearcache();
}

static inline RealType getmudim() { return ToReal(FORTRAN(ltregul).mudim); }


static inline void setdelta(cRealType delta)
{
  FORTRAN(ltregul).delta = ToREAL(delta);
  clearcache();
}

static inline RealType getdelta() { return ToReal(FORTRAN(ltregul).delta); }


static inline void setlambda(cRealType lambda)
{
  FORTRAN(ltregul).lambda = ToREAL(lambda);
  clearcache();
}

static inline RealType getlambda() { return ToReal(FORTRAN(ltregul).lambda); }


static inline void setminmass(cRealType minmass)
{
  FORTRAN(ltregul).minmass = ToREAL(minmass);
  clearcache();
}

static inline RealType getminmass() { return ToReal(FORTRAN(ltregul).minmass); }


static inline void setmaxdev(cRealType maxdev)
{
  FORTRAN(ltvars).maxdev = ToREAL(maxdev);
}

static inline RealType getmaxdev() { return ToReal(FORTRAN(ltvars).maxdev); }


static inline void setwarndigits(const int warndigits)
{
  FORTRAN(ltvars).warndigits = warndigits;
}

static inline int getwarndigits() { return FORTRAN(ltvars).warndigits; }


static inline void seterrdigits(const int errdigits)
{
  FORTRAN(ltvars).errdigits = errdigits;
}

static inline int geterrdigits() { return FORTRAN(ltvars).errdigits; }


static inline void setversionkey(const int versionkey)
{
  FORTRAN(ltvars).versionkey = versionkey;
  clearcache();
}

static inline int getversionkey() { return FORTRAN(ltvars).versionkey; }


static inline void setdebugkey(const int debugkey)
{
  FORTRAN(ltvars).debugkey = debugkey;
}

static inline int getdebugkey() { return FORTRAN(ltvars).debugkey; }


static inline void setdebugrange(const int debugfrom, const int debugto)
{
  FORTRAN(ltvars).debugfrom = debugfrom;
  FORTRAN(ltvars).debugto = debugto;
}


static inline void setcmpbits(const int cmpbits)
{
  FORTRAN(ltcache).cmpbits = cmpbits;
}

static inline int getcmpbits() { return FORTRAN(ltcache).cmpbits; }

#endif

