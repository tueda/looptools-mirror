* C0.F
* the scalar three-point function
* this file is part of LoopTools
* last modified 12 Jun 09 th

#include "defs.h"


	double complex function C0(p1, p2, p1p2, m1, m2, m3)
	implicit none
	double precision p1, p2, p1p2, m1, m2, m3

#include "lt.h"

	double complex CDispatch, C0ir, C0coll, C0irDR, C0collDR
	external CDispatch, C0ir, C0coll, C0irDR, C0collDR

	double complex res(0:1)
	double precision xpi(6)
	integer key, ier

	xpi(1) = m1
	xpi(2) = m2
	xpi(3) = m3
	xpi(4) = p1
	xpi(5) = p2
	xpi(6) = p1p2

	if( lambda .le. 0 ) then
	  C0 = CDispatch(xpi, C0irDR, C0collDR)
	  return
	endif

	ier = 0
	key = ibits(versionkey, KeyC0, 2)

	if( key .ne. 1 ) then
	  call ffxc0(res(0), xpi, ier)
	  if( ier .gt. warndigits ) then
	    ier = 0
	    call ffxc0r(res(0), xpi, ier)
	    if( ier .gt. warndigits ) key = ior(key, 2)
	  endif
	endif

	if( key .ne. 0 ) then
	  res(1) = CDispatch(xpi, C0ir, C0coll)
	  if( key .gt. 1 .and.
     &        abs(res(0) - res(1)) .gt. maxdev*abs(res(0)) ) then
	    print *, "Discrepancy in C0:"
	    print *, "  p1   =", p1
	    print *, "  p2   =", p2
	    print *, "  p1p2 =", p1p2
	    print *, "  m1   =", m1
	    print *, "  m2   =", m2
	    print *, "  m3   =", m3
	    print *, "C0 a   =", res(0)
	    print *, "C0 b   =", res(1)
	    if( ier .gt. errdigits ) res(0) = res(1)
	  endif
	endif

	C0 = res(iand(key, 1))
	end

************************************************************************
* adapter code for C++

	subroutine c0sub(res, p1, p2, p1p2, m1, m2, m3)
	implicit none
	double complex res
	double precision p1, p2, p1p2, m1, m2, m3

	double complex C0
	external C0

	res = C0(p1, p2, p1p2, m1, m2, m3)
	end

************************************************************************

	double complex function CDispatch(xpi, csoft, ccoll)
	implicit none
	double precision xpi(6)
	double complex csoft, ccoll
	external csoft, ccoll

#include "lt.h"

	integer i, ip1, im1, z
	double precision tmp

	double complex C0reg, C0reg0, C0reg00
	external C0reg, C0reg0, C0reg00

	z = 0
	do i = 1, 3
	  if( abs(xpi(i)) .lt. eps ) then
	    ip1 = ibits(X'231', 4*(3-i), 4)
	    im1 = ibits(X'312', 4*(3-i), 4)
	    if( abs(xpi(i+3) - xpi(ip1)) +
     &          abs(xpi(im1+3) - xpi(im1)) .lt. acc ) then
	      CDispatch = csoft(xpi(ip1+3), xpi(i+3), xpi(im1+3))
	      return
	    endif
	    if( abs(xpi(i+3)) + abs(xpi(ip1)) .lt. eps ) then
	      CDispatch = ccoll(xpi(ip1+3), xpi(im1+3), xpi(im1))
	      return
	    endif
	    z = z + 1
	    if( i .gt. z ) then
	      tmp = xpi(z)
	      xpi(z) = xpi(i)
	      xpi(i) = tmp
	      tmp = xpi(z+3)
	      xpi(z+3) = xpi(i+3)
	      xpi(i+3) = tmp
	    endif
	  endif
	enddo

	if( xpi(1) .ne. 0 ) then
	  CDispatch = C0reg(xpi)
	else if( xpi(2) .ne. 0 ) then
	  CDispatch = C0reg0(xpi)
	else
	  CDispatch = C0reg00(xpi)
	endif
	end

************************************************************************
* the following routines are adapted from Ansgar Denner's bcanew.f
* to the conventions of LoopTools;
* they are used for double-checking the results of FF

* all mom-squares != 0

	double complex function C0reg(xpi)
	implicit none
	double precision xpi(6)

#include "lt.h"

	double precision m(5), q(5), mki, mkj, mij, qijk
	double complex a, b, h, h0, h1, h2, h3, h4
	double complex y1, y2, y3, y4, x1, x2, x3, x4
	integer i, j, k

	double complex spence
	integer eta_n
	external spence, eta_n

	m(1) = xpi(1)
	m(2) = xpi(2)
	m(3) = xpi(3)
	m(4) = m(1)
	m(5) = m(2)

	q(1) = xpi(4)
	q(2) = xpi(5)
	q(3) = xpi(6)
	q(4) = q(1)
	q(5) = q(2)

	C0reg = 0

	a = sqrt(DCMPLX((q(2) - q(1) - q(3))**2 - 4*q(1)*q(3)))

	do i = 1, 3
	  j = i + 1
	  k = i + 2
	  mki = m(k) - m(i)
	  mkj = m(k) - m(j)
	  mij = m(i) - m(j)
	  qijk = q(i) - q(j) - q(k)
	  h2 = .5D0/(a*q(i))

	  h = q(i)*(qijk + mki + mkj) - mij*(q(j) - q(k))
	  y1 = h2*(h + a*(q(i) - mij))
	  y2 = h2*(h - a*(q(i) + mij))
	  b = sqrt(DCMPLX((q(i) - mij)**2 - 4*q(i)*m(j)))
	  y3 = h2*(h + a*b)
	  y4 = h2*(h - a*b)

	  h0 = q(i)*(q(j)*q(k) + qijk*m(k) + mki*mkj) -
     &      mij*(q(j)*mki - q(k)*mkj)
	  qijk = q(j) - q(k) - q(i)
	  h3 = h0 + q(j)*qijk*m(i) + q(k)*(q(k) - q(i) - q(j))*m(j)
	  if( abs(y3) .lt. abs(y4) ) then
	    y3 = h3/(a**2*q(i)*y4)
	  else
	    y4 = h3/(a**2*q(i)*y3)
	  endif
	  if( a*b .ne. 0 ) then
	    y3 = y3 + cI*eps*abs(a*b*y3)/(a*b)
	    y4 = y4 - cI*eps*abs(a*b*y4)/(a*b)
	  else
	    y3 = y3*(1 + cI*eps)
	    y4 = y4*(1 - cI*eps)
	  endif

	  h1 = h2*(h - a*(q(i) - mij))
	  if( abs(y1) .lt. abs(h1) ) then
	    h3 = (q(i) - q(j) + mki)*(mkj*q(i) - mij*q(j)) +
     &        (q(i) - mij)*(q(j) - mkj)*q(k)
	    y1 = h3/(a**2*q(i)*h1)
	  endif
	  h1 = h2*(h + a*(q(i) + mij))
	  if( abs(y2) .lt. abs(h1) ) then
	    h3 = (q(i) - q(k) + mkj)*(mki*q(i) + mij*q(k)) +
     &        (q(i) + mij)*(q(k) - mki)*q(j)
	    y2 = h3/(a**2*q(i)*h1)
	  endif

	  C0reg = C0reg +
     &      spence(y2/y3, 0) + spence(y2/y4, 0) -
     &      spence(y1/y3, 0) - spence(y1/y4, 0)

	  if( DIMAG(a) .ne. 0 ) then
	    h3 = abs(b)/b*eps*cI
	    x1 = -.5D0*(q(i) - mij + b)/q(i) - h3
	    x2 = -.5D0*(q(i) - mij - b)/q(i) - h3
	    x3 = -.5D0*(-q(i) - mij + b)/q(i) - h3
	    x4 = -.5D0*(-q(i) - mij - b)/q(i) - h3
	    h3 = 1/y3
	    h4 = 1/y4
	    h = log(y1)*(eta_n(x1, x2) + eta_n(h3, h4) -
     &                   eta_n(x1, h3) - eta_n(x2, h4) ) -
     &          log(y2)*(eta_n(x3, x4) + eta_n(h3, h4) -
     &                   eta_n(x3, h3) - eta_n(x4, h4) ) +
     &          log(y3)*(eta_n(x1, h3) - eta_n(x3, h3)) +
     &          log(y4)*(eta_n(x2, h4) - eta_n(x4, h4))
	    if( DIMAG(a) .gt. 0 .and. q(i) .lt. 0 )
     &        h = h - log(y1/y2)
	    C0reg = C0reg + 2*pi*cI*h
	  endif
	enddo

	C0reg = C0reg/a
	end

************************************************************************
* one mom-square zero

	double complex function C0reg0(xpi)
	implicit none
	double precision xpi(6)

#include "lt.h"

	double precision m(5), q(5), mki, mkj, mij, qijk, ar
	double complex b, h, h0, h3
	double complex y1, y2, y3, y4
	integer i, j, k

	double complex spence
	external spence

	m(1) = xpi(1)
	m(2) = xpi(2)
	m(3) = xpi(3)
	m(4) = m(1)
	m(5) = m(2)

	q(1) = xpi(4)
	q(2) = xpi(5)
	q(3) = xpi(6)
	q(4) = q(1)
	q(5) = q(2)

	C0reg0 = 0

	ar = q(2) - q(3)
	do i = 2, 3
	  j = i + 1
	  k = i + 2
	  mki = m(k) - m(i)
	  mkj = m(k) - m(j)
	  mij = m(i) - m(j)
	  qijk = q(i) - q(j) - q(k)

	  if( i .eq. 2 ) then
	    y1 = 2*q(2)*(mki + ar)
	    y2 = 2*q(2)*mki
	  else
	    y1 = 2*q(3)*mkj
	    y2 = 2*q(3)*(mkj - ar)
	  endif
	  h = q(i)*(qijk + mki + mkj) - mij*(q(j) - q(k))
	  b = sqrt(DCMPLX((q(i) - mij)**2 - 4*q(i)*m(j)))
	  y3 = h + ar*b
	  y4 = h - ar*b

	  h0 = q(i)*(q(j)*q(k) + qijk*m(k) + mki*mkj) -
     &      mij*(q(j)*mki - q(k)*mkj)
	  h3 = h0 + q(j)*(q(j) - q(k) - q(i))*m(i) + 
     &              q(k)*(q(k) - q(i) - q(j))*m(j)
	  h3 = 4*h3*q(i)
	  if( abs(y3) .lt. abs(y4) ) then
	    y3 = h3/y4
	  else
	    y4 = h3/y3
	  endif
	  qijk = ar/q(i)
	  if( qijk .ne. 0 ) then
	    y3 = y3 + cI*eps/qijk*abs(qijk*y3)
	    y4 = y4 - cI*eps/qijk*abs(qijk*y4)
	  else
	    y3 = y3*(1 + cI*eps)
	    y4 = y4*(1 - cI*eps)
	  endif

	  C0reg0 = C0reg0 +
     &      spence(y2/y3, 0) + spence(y2/y4, 0) -
     &      spence(y1/y3, 0) - spence(y1/y4, 0)
	enddo

	C0reg0 = C0reg0/ar
	end

************************************************************************
* two mom-squares zero

	double complex function C0reg00(xpi)
	implicit none
	double precision xpi(6)

#include "lt.h"

	double precision m(5), q(5), mki, mkj, mij, qijk
	double complex b, h, h0
	double complex y1, y2, y3, y4

	double complex spence
	external spence

	m(1) = xpi(1)
	m(2) = xpi(2)
	m(3) = xpi(3)
	m(4) = m(1)
	m(5) = m(2)

	q(1) = xpi(4)
	q(2) = xpi(5)
	q(3) = xpi(6)
	q(4) = q(1)
	q(5) = q(2)

	C0reg00 = 0

	mki = m(2) - m(3)
	mkj = m(2) - m(1)
	mij = m(3) - m(1)

	if( abs(mki) .gt. acc ) then
	  y1 = -q(3) - mkj
	  y2 = -mkj
	  qijk = -mkj - q(3)*m(2)/mki
	  y3 = qijk - cI*eps*sign(1D0, -q(3)/mki)*abs(qijk)
	  C0reg00 = C0reg00 + spence(y2/y3, 0) - spence(y1/y3, 0)
	endif

	b = sqrt(DCMPLX((q(3) - mij)**2 - 4*q(3)*m(1)))
	h = q(3)*(q(3) + mki + mkj)
	y1 = 2*q(3)*mkj
	y2 = 2*q(3)*(q(3) + mkj)
	y3 = h - q(3)*b
	y4 = h + q(3)*b
	h0 = 4*q(3)**2*(q(3)*m(2) + mki*mkj)
	if( abs(y3) .lt. abs(y4) ) then
	  y3 = h0/y4
	else
	  y4 = h0/y3
	endif
	y3 = y3 - cI*eps*abs(y3)
	y4 = y4 + cI*eps*abs(y4)

	C0reg00 = -(C0reg00 +
     &    spence(y2/y3, 0) + spence(y2/y4, 0) -
     &    spence(y1/y3, 0) - spence(y1/y4, 0))/q(3)
	end

************************************************************************

	double complex function C0ir(s, m1, m2)
	implicit none
	double precision s, m1, m2

#include "lt.h"

	double complex spence, ln
	external spence, ln

	double precision ma, mb, a, h1, h2, h3, ps
	double complex c

	if( abs(m1) .lt. minmass .or. abs(m2) .lt. minmass ) then
	  if( abs(m1) .gt. minmass ) then
	    mb = m1
	    ma = m2
	  else if( abs(m2) .gt. minmass ) then
	    ma = m2
	    mb = m1
	  else
	    c = -1/(s + cI*eps)
	    C0ir = 1/s*(log(lambda*c)*log(sqrt(m1*m2)*c) -
     &        .25D0*(log(m1*c) + log(m2*c)) - pi6)
	    return
	  endif
	  c = s + cI*eps
	  C0ir = 1/(s - mb)*(log(sqrt(ma/mb)*(mb - c)/lambda)*
     &      log((mb - c)/sqrt(ma*mb)) + spence(c/mb, 0))
*<<< FIXME: testing
	endif

	if( abs(m1) .lt. acc .or. abs(m2) .lt. acc ) then
	  print *, "C0ir: mass-singular case"
	  C0ir = nan
	  return
	endif

	if( abs(s) .lt. acc ) then
	  if( abs(m1 - m2) .lt. acc ) then
	    C0ir = -.5D0*log(m1/lambda)/m1
	  else
	    C0ir = -.25D0*log(m2*m1/lambda**2)*
     &        log(m1/m2)/(m1 - m2)
	  endif
	  return
	endif

	ps = s - m1 - m2
	a = ps**2 - 4*m1*m2
	if( a .lt. 0 ) then
	  print *, "C0ir: complex square root not implemented"
	  a = 0
	endif
	a = sqrt(a)
	if( ps .le. 0 ) then
	  h1 = .5D0*(a - ps)
	else
	  h1 = -2*m1*m2/(a + ps)
	endif
	ps = s - m1 + m2
	if( ps .le. 0 ) then
	  h2 = .5D0*(a - ps)
	else
	  h2 = -2*s*m2/(a + ps)
	endif
	ps = s + m1 - m2
	if( ps .le. 0 ) then
	  h3 = .5D0*(a - ps)
	else
	  h3 = -2*m1*s/(a + ps)
	endif

	c = ln(-a/s, -1)
	C0ir = (-pi6 +
     &    spence(DCMPLX(h2/a), -1) + spence(DCMPLX(h3/a), -1) -
     &    .5D0*(ln(-h2/s, -1)**2 + ln(-h3/s, -1)**2) +
     &    .25D0*(ln(-m1/s, -1)**2 + ln(-m2/s, -1)**2) -
     &    c*(ln(-h1/s, -1) - c) +
     &    ln(-lambda/s, -1)*ln(h1/sqrt(m1*m2), 1))/a
	end

************************************************************************

	double complex function C0irDR(s, m1, m2)
	implicit none
	double precision s, m1, m2

#include "lt.h"

	double precision m, dm, rat
	double complex root, fac, mK, logmK, wlog, wlogm

	double complex li2omx2, lnrat, cln, spence
	external li2omx2, lnrat, cln, spence

	if( abs(m1) .lt. minmass .and. abs(m2) .lt. minmass ) then
	  if( abs(m1) .gt. minmass ) then
	    m = m1
	  else if( abs(m2) .gt. minmass ) then
	    m = m2
	  else
	    if( abs(s) .lt. eps ) then
	      print *, "C0irDR: all scales zero"
	      C0irDR = nan
	      return
	    endif
	    if( lambda .eq. -2 ) then
	      C0irDR = 1/s
	    else if( lambda .eq. -1 ) then
	      C0irDR = lnrat(mudim, -s)/s
	    else
	      C0irDR = .5D0*lnrat(mudim, -s)**2/s
	    endif
	    return
	  endif
	  if( abs(s - m) .lt. acc ) then
	    if( lambda .eq. -2 ) then
	      C0irDR = 0
	    else if( lambda .eq. -1 ) then
	      C0irDR = -.5D0/m
	    else
	      C0irDR = (-.5D0*lnrat(mudim, m) + 1)/m
	    endif
	    return
	  endif

	  if( lambda .eq. -2 ) then
	    C0irDR = .5D0/(s - m)
	  else if( lambda .eq. -1 ) then
	    C0irDR = (.5D0*lnrat(mudim, m) + lnrat(m, m - s))/(s - m)
	  else
	    wlog = lnrat(m, m - s)
	    wlogm = lnrat(mudim, m)
	    C0irDR = (wlogm*(wlogm + wlog) + .5D0*wlog**2 + pi12 -
     &        spence(DCMPLX(s/(s - m)), 0))/(s - m)
	  endif
	  return
	endif

	if( lambda .eq. -2 ) then
	  C0irDR = 0
	  return
	endif

	m = sqrt(m1*m2)
	dm = (sqrt(m1) - sqrt(m2))**2
	rat = s - dm
	root = sqrt(DCMPLX((rat - 4*m)/rat))
	mK = -4*m/(rat*(1 + root)**2)

	if( abs(mK - 1) .lt. acc ) then
	  if( lambda .eq. -1 ) then
	    C0irDR = .5D0/m
	  else
	    C0irDR = 0
	    if( abs(m1 - m2) .gt. acc )
     &        C0irDR = 2 + .5D0*(m2 - m1)/dm*log(m2/m1)
	    C0irDR = .5D0/m*(log(mudim/m) - C0irDR)
	  endif
	  return
	endif

	logmK = cln(mK, 1)
	fac = -1/(rat*root)

	if( lambda .eq. -1 ) then
	  C0irDR = -fac*logmK
	else
	  C0irDR = fac*( logmK*(-.5D0*logmK - log(mudim/m)) -
     &      li2omx2(mK, mK, 1, 1) +
     &      .125D0*log(m1/m2)**2 +
     &      li2omx2(mK, DCMPLX(sqrt(m1/m2)), 1, 0) +
     &      li2omx2(mK, DCMPLX(sqrt(m2/m1)), 1, 0) )
	endif
	end

************************************************************************

	double complex function C0collDR(s1, s2, m)
	implicit none
	double precision s1, s2, m

#include "lt.h"

	double precision m1, m2, r
	double complex wlog1, wlog2, wlogm

	double complex li2omrat, lnrat
	external li2omrat, lnrat

	if( lambda .eq. -2 ) then
	  C0collDR = 0
	  return
	endif

	if( abs(m) .lt. eps ) then
	  r = .5D0*(s2 - s1)/s1
	  if( abs(r) .lt. acc ) then
	    if( lambda .eq. -1 ) then
	      C0collDR = (1 - r*mudim/s1)/s1
	    else
	      C0collDR = (lnrat(mudim, -s1)*(1 - r) - r)/s1
	    endif
	    return
	  endif
	  wlog1 = lnrat(mudim, -s1)
	  wlog2 = lnrat(mudim, -s2)
	  C0collDR = (wlog1 - wlog2)/(s1 - s2)
	  if( lambda .ne. -1 )
     &      C0collDR = .5D0*(wlog1 + wlog2)*C0collDR
	  return
	endif

	m1 = m - s1
	m2 = m - s2
	wlog1 = lnrat(m1, m)
	wlog2 = lnrat(m2, m)
	wlogm = lnrat(mudim, m)

	r = .5D0*(s1 - s2)/m1
	if( abs(r) .lt. acc ) then
	  if( lambda .eq. -1 ) then
	    C0collDR = (1 - r)/m1
	  else
	    m2 = m/s1
	    C0collDR = (wlogm - (m2 + 1)*wlog2 -
     &        r*((m2*(m2 - 2) - 1)*wlog2 + m2 + 1 + wlogm))/m1
	  endif
	  return
	endif

	C0collDR = wlog2 - wlog1
	if( lambda .ne. -1 ) C0collDR =
     &    (wlogm - wlog1 - wlog2)*C0collDR +
     &    li2omrat(m1, m) - li2omrat(m2, m)
	C0collDR = C0collDR/(s1 - s2)
	end

